var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = SchottkyAnoMaLy","category":"page"},{"location":"#SchottkyAnoMaLy","page":"Home","title":"SchottkyAnoMaLy","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for SchottkyAnoMaLy.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [SchottkyAnoMaLy]","category":"page"},{"location":"#SchottkyAnoMaLy.DonutVolcanoEnsemble","page":"Home","title":"SchottkyAnoMaLy.DonutVolcanoEnsemble","text":"DonutVolcanoEnsemble{T <: Real}\n\nAn ensemble of M donutvolcanos takes the form \n\nmathrmp_M(x) = frac1M sum_k=1^M mathrmdonutvolcano(x mu_k sigma_k)\n\nThis object is a wrapper around an ensemble::Vector{Tuple{T, T}} for the individual donutvolcanos. The values of (μ_k σ_k) are restricted such that mu_k geq 0 and sigma_k  0 via the valid function.\n\n\n\n\n\n","category":"type"},{"location":"#SchottkyAnoMaLy.DonutVolcanoEnsemble-Tuple{Any}","page":"Home","title":"SchottkyAnoMaLy.DonutVolcanoEnsemble","text":"(::DonutVolcanoEnsemble)(x)\n\nEvaluate the DonutVolcanoEnsemble as a function over a set of values x.\n\njulia> dve = DonutVolcanoEnsemble(Float64, [(0, 1)]);\n\njulia> dve(2)\n0.2706705664732254\n\njulia> dve([3, 4])\n2-element Vector{Float64}:\n 0.033326989614726917\n 0.0013418505116100474\n\n\n\n\n\n","category":"method"},{"location":"#SchottkyAnoMaLy.DonutVolcanoEnsemble-Union{Tuple{Array{Tuple{T, T}, 1}}, Tuple{T}} where T","page":"Home","title":"SchottkyAnoMaLy.DonutVolcanoEnsemble","text":"DonutVolcanoEnsemble(args...)\n\nVarious interfaces to a DonutVolcanoEnsemble\n\nCopy/Move constructors\n\nDonutVolcanoEnsemble(::Vector{Tuple{T, T}})\nCreate an ensemble from a Vector of (μ, σ) Tuples of the same Type.\nDonutVolcanoEnsemble(::Vector{Tuple{T, U}})\nCreate an ensemble from a Vector of (μ, σ) Tuples of the different Types. \nThe type of the ensemble is chosen by Base.promote_type.\nDonutVolcanoEnsemble(::Type{S}, ::Vector{Tuple{T, U}})\nCreate an ensemble from a Vector of (μ, σ) Tuples of the different Types into an ensemble of with preferred type S.\nThe ultimate type of the ensemble is chosen by Base.promote_type.\n\nnote: Note\nThe constructors above will check that any supplied pair is valid.\n\nEmpty constructors\n\nDonutVolcanoEnsemble(::Type{S})\nCreate an empty ensemble of chosen type S.\nDonutVolcanoEnsemble()\nCreate an empty ensemble. By default the type is Float64.\n\n\n\n\n\n","category":"method"},{"location":"#SchottkyAnoMaLy.NLevelSystem","page":"Home","title":"SchottkyAnoMaLy.NLevelSystem","text":"abstract type NLevelSystem  end\n\nCreate a supertype for all non-interacting systems with discrete  energy levels. \n\nEach new concrete subtype must define a specific_heat function.\n\n\n\n\n\n","category":"type"},{"location":"#SchottkyAnoMaLy.RandomDonutVolcanoGenerator","page":"Home","title":"SchottkyAnoMaLy.RandomDonutVolcanoGenerator","text":"RandomDonutVolcanoGenerator{T <: Real}\n\nObject to generate a random DonutVolcanoEnsemble.\n\n\n\n\n\n","category":"type"},{"location":"#SchottkyAnoMaLy.TwoLevelSystem","page":"Home","title":"SchottkyAnoMaLy.TwoLevelSystem","text":"struct TwoLevelSystem end\n\nEmpty struct for the case of the two-level system. Subtype of NLevelSystem. Used to define traits for this specific type of system.\n\n\n\n\n\n","category":"type"},{"location":"#Base.append!-Union{Tuple{T}, Tuple{DonutVolcanoEnsemble{T}, Any}} where T","page":"Home","title":"Base.append!","text":"Base.append!(::DonutVolcanoEnsemble, vals)\n\nAppend the vals::Vector{Tuple{S, T}} to the DonutVolcanoEnsemble.\n\njulia> dve = DonutVolcanoEnsemble()\nDonutVolcanoEnsemble{Float64}(Tuple{Float64, Float64}[])\n\njulia> append!(dve, [(0, 1), (1, 3)])\n2-element Vector{Tuple{Float64, Float64}}:\n (0.0, 1.0)\n (1.0, 3.0)\n\njulia> dve\nDonutVolcanoEnsemble{Float64}([(0.0, 1.0), (1.0, 3.0)])\n\nnote: Note\nThis function will check that the pair is valid.\n\n\n\n\n\n","category":"method"},{"location":"#Base.eltype-Union{Tuple{DonutVolcanoEnsemble{T}}, Tuple{T}} where T","page":"Home","title":"Base.eltype","text":"Base.eltype(::DonutVolcanoEnsemble)\n\nReturn the type of the DonutVolcanoEnsemble.\n\njulia> dve = DonutVolcanoEnsemble()\nDonutVolcanoEnsemble{Float64}(Tuple{Float64, Float64}[])\n\njulia> eltype(dve)\nFloat64\n\n\n\n\n\n","category":"method"},{"location":"#Base.length-Tuple{DonutVolcanoEnsemble}","page":"Home","title":"Base.length","text":"length(::DonutVolcanoEnsemble)\n\nReturn the number of donutvolcano in the DonutVolcanoEnsemble.\n\n\n\n\n\n","category":"method"},{"location":"#Base.push!-Union{Tuple{T}, Tuple{DonutVolcanoEnsemble{T}, Any}} where T","page":"Home","title":"Base.push!","text":"Base.push!(::DonutVolcanoEnsemble, pair)\n\nPush a new (μ, σ) Tuple into a given DonutVolcanoEnsemble.\n\njulia> dve = DonutVolcanoEnsemble()\nDonutVolcanoEnsemble{Float64}(Tuple{Float64, Float64}[])\n\njulia> push!(dve, (0, 1))\n1-element Vector{Tuple{Float64, Float64}}:\n (0.0, 1.0)\n\njulia> dve\nDonutVolcanoEnsemble{Float64}([(0.0, 1.0)])\n\nnote: Note\nThis function will check that the pair is valid.\n\n\n\n\n\n","category":"method"},{"location":"#Base.rand-Union{Tuple{T}, Tuple{Random.AbstractRNG, RandomDonutVolcanoGenerator{T}, Int64}} where T","page":"Home","title":"Base.rand","text":"rand([rng = GLOBAL_RNG], ::RandomDonutVolcanoGenerator{T}, num_ensembles::Int)\n\nReturn a Vector of random DonutVolcanoEnsembles of length num_ensembles. The type of each DonutVolcanoEnsemble is T. By default, the GLOBAL_RNG is used.\n\n\n\n\n\n","category":"method"},{"location":"#Base.rand-Union{Tuple{T}, Tuple{Random.AbstractRNG, RandomDonutVolcanoGenerator{T}}} where T","page":"Home","title":"Base.rand","text":"rand([rng = GLOBAL_RNG], ::RandomDonutVolcanoGenerator{T})\n\nGenerate a random DonutVolcanoEnsemble of type T based on the  RandomDonutVolcanoGenerator supplied. By default, T = Float64.\n\njulia> using Random \n\njulia> rng = MersenneTwister(42);  # Choice for longevity. Use Xoshiro in practice or the GLOBAL_RNG.\n\njulia> rdveg = RandomDonutVolcanoGenerator(3, 10, 10);\n\njulia> dve = rand(rng, rdveg);     # Suppress output for floating-point error reasons.\n\njulia> for tup ∈ ensemble(dve)\n           @show round.( tup; digits = 6 )\n       end\nround.(tup; digits = 6) = (6.23099, 2.780566)\nround.(tup; digits = 6) = (9.745867, 4.499406)\nround.(tup; digits = 6) = (8.427712, 3.660781)\n\n\n\n\n\n","category":"method"},{"location":"#SchottkyAnoMaLy.Theta-Tuple{Any}","page":"Home","title":"SchottkyAnoMaLy.Theta","text":"Theta(x)\n\nPackage-specific implementation of the Heaviside Theta function. Our definition is\n\nTheta(x) = begincases\n1  x geq 0\n\n0  mathrmotherwise\nendcases\n\n\n\n\n\n","category":"method"},{"location":"#SchottkyAnoMaLy.chebycoefficients","page":"Home","title":"SchottkyAnoMaLy.chebycoefficients","text":"chebycoefficients(ensembles, order, Δmin, Δmax, [coefftol = zero(Float64)])\n\nAllocate the appropriate coefficients Matrix and pass it to chebycoefficients!.\n\n\n\n\n\n","category":"function"},{"location":"#SchottkyAnoMaLy.chebycoefficients!","page":"Home","title":"SchottkyAnoMaLy.chebycoefficients!","text":"chebycoefficients!(coefficients, ensembles, order, Δmin, Δmax, [coefftol = zero(Float64)])\n\nCompute all of the Chebyshev coefficients for each of the ensembles to a given order on the  interval [Δmin, Δmax]. This function uses chebydecomposition to do so, and assumes the  coefficients argument is a length(ensembles) × (order + 1) Matrix.\n\nBecause this is a somewhat complex calculation, it should probably be calculated once.\n\n\n\n\n\n","category":"function"},{"location":"#SchottkyAnoMaLy.chebydecomposition","page":"Home","title":"SchottkyAnoMaLy.chebydecomposition","text":"chebydecomposition(ensemble, order, Δmin, Δmax, [ coefftol = zero(Float64) ])\n\nUse FastChebInterp.jl to compute the Chebyshev interpolation of a given ensemble to a polynomial order on the [Δmin, Δmax] interval. This function returns the  coefficients a_k computed by FastChebInterp.chebinterp and defined by \n\nmathrmp(Delta) approx sum_k=0^M a_k T_k(Delta)\n\nwhere mathrmp(Delta) is the ensemble, M is the order, and T_k(Delta) is the k^mathrmth Chebyshev polynomial of the first kind.\n\nnote: Note\nChanging the optional coefftol from the default value of 0.0 may lead to issues downstream. Essentially, FastChebInterp.jl uses this (I think) for precision purposes, but if it is nonzero then the output order is not guaranteed to be what is provided as and argument.\n\n\n\n\n\n","category":"function"},{"location":"#SchottkyAnoMaLy.compute_cVs!-Tuple{Any, Any, Any}","page":"Home","title":"SchottkyAnoMaLy.compute_cVs!","text":"compute_cVs!( cV_arr, ensembles, temps; [kwargs...] )\n\nCompute the specific_heat at each temperature in temps for  a given ensemble as a single column. By assumption, cV_arr is a  length(temps) × length(ensembles) Matrix, and it has been initialized with zeros.\n\nKeyword arguments\n\nnls =TwoLevelSystem(): The type of NLevelSystem used to compute the specific_heat.\nΔmin = 0.: The minimum value of the level-splitting in the integration over each ensemble.\nΔmax = Inf: The maximum value of the level-splitting in the integration over each ensemble.\nrtol = sqrt(eps()): The relative tolerance used in QuadGK.quadgk to integrate over the ensembles.\n\nnote: Note\nSince this populates the specific heat values with QuadGK.quadgk, it is best only to compute once as it's a bit of an expensive operation.\n\n\n\n\n\n","category":"method"},{"location":"#SchottkyAnoMaLy.compute_cVs-Tuple{Any, Any}","page":"Home","title":"SchottkyAnoMaLy.compute_cVs","text":"compute_cVs(ensembles, temps; [kwargs...])\n\nCreates a zero Matrix of size length(temps) × length(ensembles) and  passes it to compute_cVs!.\n\n\n\n\n\n","category":"method"},{"location":"#SchottkyAnoMaLy.donutvolcano-Tuple{Any, Any, Any}","page":"Home","title":"SchottkyAnoMaLy.donutvolcano","text":"donutvolcano(x, μ, σ)\n\nThe donutvolcano distribution calculated for an input x with center μ and width σ. The argument x can be a scalar or broadcastable.\n\nThe distribution itself is given by \n\nrm donutvolcano(x μ σ) = fracx Theta(x)mathcalN(musigma) expleft -fracleft(x - muright)^22sigma^2 right\n\nwhere we use our own Heaviside Theta function above. The normalization constant mathcalN(musigma) given by norm_donutvolcano.\n\n\n\n\n\n","category":"method"},{"location":"#SchottkyAnoMaLy.ensemble-Tuple{DonutVolcanoEnsemble}","page":"Home","title":"SchottkyAnoMaLy.ensemble","text":"ensemble(::DonutVolcanoEnsemble)\n\nGetter for the Vector{Tuple{T, T}} of the given ensemble.\n\n\n\n\n\n","category":"method"},{"location":"#SchottkyAnoMaLy.gausskernel-Tuple{Any, Any}","page":"Home","title":"SchottkyAnoMaLy.gausskernel","text":"gausskernel(d2, hypσ, [method = TrapezoidalFast()])\ngausskernel(xdata, y1data, y2data, hypσ, [method = TrapezoidalFast()])\n\nCompute the Gaussian kernel function for two sets of ydata, given the hyperparameter hypσ.  This kernel function is of the form\n\nKy_1(x) y_2(x) sigma = expleft - fracd^2y_1(x) y_2(x)2sigma^2 right\n\nwhere d^2 is the msqdiff functional.\n\n\n\n\n\n","category":"method"},{"location":"#SchottkyAnoMaLy.get_pair-Tuple{DonutVolcanoEnsemble, Any}","page":"Home","title":"SchottkyAnoMaLy.get_pair","text":"get_pair(::DonutVolcanoEnsemble, pair_idx) -> Tuple{T, T}\n\nGetter for a single pair (Tuple{T, T}) at a specified pair_idx.\n\n\n\n\n\n","category":"method"},{"location":"#SchottkyAnoMaLy.kernel-Tuple{Any, Any}","page":"Home","title":"SchottkyAnoMaLy.kernel","text":"kernel(msqdiff_matrix, hypσ)\n\nCompute the element-wise gausskernel of the msqdiff_matrix with respect to the hyperparameter hypσ. This makes a copy.\n\n\n\n\n\n","category":"method"},{"location":"#SchottkyAnoMaLy.mass2","page":"Home","title":"SchottkyAnoMaLy.mass2","text":"mass2( xdata, ydata, [method = TrapezoidalFast()] )\n\nUse NumericalIntegration.jl to compute the \"mean-square-mass\" of a set of data ydata over the domain xdata. \n\nnote: Note\nThe default IntegrationMethod is set to TrapezoidalFast which will lead  to errors if xdata and ydata are of different lengths. For experimental data inputs, however, this should be fine because the specific heat is  measured for a specific temperature.\n\nThe mean-square-mass formula, given as a continuous integral, is \n\nm^2y(x) = frac1b - aint_a^b mathrmdx left y(x) right^2\n\njulia> xvals = LinRange(1, 10, 10);\n\njulia> yvals = sqrt.(xvals);  # In this case the trapezoidal rule is exact\n\njulia> value = SchottkyAnoMaLy.mass2(xvals, yvals)\n5.5\n\njulia> value ≈ 1/(10 - 1) * 1/2 * ( maximum(xvals)^2 - minimum(xvals)^2 )\ntrue\n\n\n\n\n\n","category":"function"},{"location":"#SchottkyAnoMaLy.msqdiff","page":"Home","title":"SchottkyAnoMaLy.msqdiff","text":"msqdiff(xdata, y1data, y2data, [method = TrapezoidalFast()])\n\nCompute the mean-square-difference between two sets of ydata on the given xdata domain. This function calls mass2 to perform the integration. \n\nThe formula for the mean-square-difference between functions y_1 and y_2 on the  continuous interval (a,b) is given by \n\nd^2(y_1 y_2) = m^2y_1(x) - y_2(x) = frac1b - aint_a^b mathrmdx left y_1(x) - y_2(x) right^2\n\n\n\n\n\n","category":"function"},{"location":"#SchottkyAnoMaLy.norm_donutvolcano-Tuple{Any, Any}","page":"Home","title":"SchottkyAnoMaLy.norm_donutvolcano","text":"norm_donutvolcano(μ, σ)\n\nThe normalization for a donutvolcano distribution with center μ and width σ. The explicit form is given by\n\nmathcalN(mu sigma) = sqrtfracpi 2 mu  sigma \n   lefttexterfleft(fracmu sqrt2 sigma\nright)+1right+sigma ^2 rm e^-fracmu ^22 sigma ^2\n\n\n\n\n\n","category":"method"},{"location":"#SchottkyAnoMaLy.populate_msqdiffs!-Tuple{Any, Any, Any}","page":"Home","title":"SchottkyAnoMaLy.populate_msqdiffs!","text":"populate_msqdiffs!( msqdiff_mat, cV_arr, temps; [kwargs...])\n\nCompute the msqdiff for each pair of specific heats in cV_arr as  a function of temperature (temps) as the xdata. This assumes that \n\nmsqdiff_mat is a N × N zero Matrix,\nN == size(cV_arr)[2], where cV_arr is a specific heat Matrix calculated from compute_cVs!,\nthe number of temperatures in temps equals the number of specific heat rows.\n\nThis populates the msqdiff_mat by exploiting the symmetry in msqdiff. So  only N(N+1)/2 elements are computed and then the matrix is symmetrized. (Hence the need for a zero matrix input.)\n\nnote: Note\nN is likely to be a large number, so it is best to use this function once.\n\n\n\n\n\n","category":"method"},{"location":"#SchottkyAnoMaLy.populate_msqdiffs-Tuple{Any, Any}","page":"Home","title":"SchottkyAnoMaLy.populate_msqdiffs","text":"populate_msqdiffs(cV_arr, temps; [kwargs...])\n\nCreates a zero Matrix of size length(ensembles) × length(ensembles) and  passes it to populate_msqdiffs!.\n\n\n\n\n\n","category":"method"},{"location":"#SchottkyAnoMaLy.specific_heat","page":"Home","title":"SchottkyAnoMaLy.specific_heat","text":"specific_heat([::NLevelSystem = TwoLevelSystem()], T, ::DonutVolcanoEnsemble, [Δmin = 0, Δmax = Inf])\n\nCalculate the specific_heat tildec_V(T Delta integrated over the DonutVolcanoEnsemble for a fixed temperature T. By default, this is calculated for a TwoLevelSystem.\n\nThe formula for this integration is given by \n\nc_V(T) = int_Delta_min^Delta_max mathrmdDelta mathrmp(Delta) tildec_V(T Delta)\n\nwhere mathrmp(Delta) is calculated from the DonutVolcanoEnsemble.\n\n\n\n\n\n","category":"function"},{"location":"#SchottkyAnoMaLy.specific_heat-Tuple{Any, Any}","page":"Home","title":"SchottkyAnoMaLy.specific_heat","text":"specific_heat(T, Δ) = specific_heat(TwoLevelSystem, T, Δ)\n\nThe default specific heat implementation chooses a TwoLevelSystem.\n\njulia> specific_heat(1, 1)\n0.41997434161402614\n\njulia> specific_heat(TwoLevelSystem(), 1, 1)\n0.41997434161402614\n\n\n\n\n\n","category":"method"},{"location":"#SchottkyAnoMaLy.specific_heat-Tuple{TwoLevelSystem, Any, Any}","page":"Home","title":"SchottkyAnoMaLy.specific_heat","text":"specific_heat(::TwoLevelSystem, T, Δ)\n\nDefine the specific heat function for a two-level system at temperature T and level-splitting Δ (measured in units of temperature). The formula is given by \n\nc_V(T Delta) = left( fracDeltaT right)^2 mathrmsech^2 left( fracDeltaT right)^2\n\njulia> specific_heat(TwoLevelSystem(), 1, 1)\n0.41997434161402614\n\n\n\n\n\n","category":"method"},{"location":"#SchottkyAnoMaLy.valid-Tuple{Any}","page":"Home","title":"SchottkyAnoMaLy.valid","text":"valid(::Tuple{T, T})\n\nReturns the given Tuple (μ, σ) if μ ≥ 0 and σ > 0. Otherwise, an AssertionError  will be thrown.\n\n\n\n\n\n","category":"method"},{"location":"#SchottkyAnoMaLy.μvalue-Union{Tuple{Tuple{T, T}}, Tuple{T}} where T","page":"Home","title":"SchottkyAnoMaLy.μvalue","text":"μvalue(::Tuple{T, T})\nμvalue(::DonutVolcanoEnsemble, idx)\n\nReturn the value of μ from a given (μ, σ) Tuple.\n\n\n\n\n\n","category":"method"},{"location":"#SchottkyAnoMaLy.σvalue-Union{Tuple{Tuple{T, T}}, Tuple{T}} where T","page":"Home","title":"SchottkyAnoMaLy.σvalue","text":"σvalue(::Tuple{T, T})\nσvalue(::DonutVolcanoEnsemble, idx)\n\nReturn the value of σ from a given (μ, σ) Tuple.\n\n\n\n\n\n","category":"method"}]
}
